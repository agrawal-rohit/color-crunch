/**
 * Calculates luminance for an RGB triplet color
 *
 * @param {number} r - Red value
 * @param {number} g - Green value
 * @param {number} b - Blue value
 * @returns {number} - Luminance
 */
export const luminance = (r: number, g: number, b: number): number => {
  let a: Array<number> = [];
  for (let v of [r, g, b]) {
    v /= 255;
    if (v <= 0.03928) {
      a.push(v / 12.92);
    } else {
      a.push(Math.pow((v + 0.055) / 1.055, 2.4));
    }
  }

  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};

/**
 * Calculates contrast between two RGB triplet colors
 *
 * @param {Array<number>} rgb1 - RGB triplet color
 * @param {Array<number>} rgb2 - RGB triplet color
 * @returns {number} - Contrast
 */
export const contrast = (rgb1: Array<number>, rgb2: Array<number>): number => {
  let lum1 = luminance(rgb1[0], rgb1[1], rgb1[2]);
  let lum2 = luminance(rgb2[0], rgb2[1], rgb2[2]);
  let brightest = Math.max(lum1, lum2);
  let darkest = Math.min(lum1, lum2);
  return (brightest + 0.05) / (darkest + 0.05);
};

/**
 * Evaluates an encoded palette solution generated by an algorithm
 *
 * @method
 * @param {Array<number>} primary_color - A color represented as an array of RGB values (0 to 255)
 * @param {Array<number>} solution - A palette encoded as a list of 15 integers (5 rgb triplet colors)
 * @returns {number} - Fitness value (Higher the better)
 */
export const evaluateSolution = (
  primary_color: Array<number>,
  solution: Array<number>
): number => {
  let eval_metric = 0;
  let accent_color = solution.slice(0, 3);
  let background = solution.slice(3, 6);
  let surface_color = solution.slice(6, 9);
  let button_text = solution.slice(9, 12);
  let main_text = solution.slice(12, 15);

  // Ensure background is not very dark or very bright and not monotone
  const backgroundLuminance = luminance(
    background[0],
    background[1],
    background[2]
  );
  const backgroundIsMonotone = background.every((val) => val === background[0]);
  if (
    backgroundLuminance > 0.2 &&
    backgroundLuminance < 0.8 &&
    !backgroundIsMonotone
  ) {
    eval_metric += 3; // Adjusted reward for suitable background luminance and color variety
  } else {
    eval_metric -= 3; // Adjusted penalty for backgrounds that are too dark, too bright, or monotone
  }

  // Basic Eval
  // Maximum contrast between text and their backgrounds
  eval_metric += contrast(primary_color, button_text);
  eval_metric += contrast(accent_color, button_text);
  eval_metric += contrast(surface_color, main_text);

  // At least AA between primary color and surface bg
  let primary_surface_contrast = contrast(primary_color, surface_color);
  if (primary_surface_contrast > 4.5) {
    eval_metric += 3; // Adjusted reward for achieving AA level contrast
  } else if (primary_surface_contrast > 3 && primary_surface_contrast <= 4.5) {
    eval_metric += 2; // Adjusted reward for moderate contrast
  } else if (primary_surface_contrast > 2 && primary_surface_contrast <= 3) {
    eval_metric += 1; // Adjusted reward for minimal contrast
  }

  let accent_surface_contrast = contrast(accent_color, surface_color);
  if (accent_surface_contrast > 4.5) {
    eval_metric += 3; // Adjusted reward for achieving AA level contrast
  } else if (accent_surface_contrast > 3 && accent_surface_contrast <= 4.5) {
    eval_metric += 2; // Adjusted reward for moderate contrast
  } else if (accent_surface_contrast > 2 && accent_surface_contrast <= 3) {
    eval_metric += 1; // Adjusted reward for minimal contrast
  }

  // At least AA Large for background and surface bg
  let background_surface_contrast = contrast(background, surface_color);
  if (background_surface_contrast > 3) {
    eval_metric += Math.min(background_surface_contrast, 7); // Reward for higher contrast, capped at 7
  } else if (
    background_surface_contrast > 2 &&
    background_surface_contrast <= 3
  ) {
    eval_metric += 2; // Adjusted reward for acceptable contrast
  } else if (
    background_surface_contrast > 1.5 &&
    background_surface_contrast <= 2
  ) {
    eval_metric += 1; // Adjusted reward for minimal contrast
  }

  // Primary color and accent color
  let primary_accent_contrast = contrast(primary_color, accent_color);
  // Ensure primary and accent colors are complementary to each other
  if (primary_accent_contrast >= 4.5 && primary_accent_contrast <= 7) {
    eval_metric += 3; // Adjusted reward for complementary primary and accent colors within optimal range
  } else if (primary_accent_contrast > 3 && primary_accent_contrast < 4.5) {
    eval_metric += 2; // Adjusted reward for good contrast
  } else if (primary_accent_contrast >= 2 && primary_accent_contrast <= 3) {
    eval_metric += 1; // Adjusted reward for acceptable contrast
  } else if (primary_accent_contrast > 7) {
    eval_metric += 1; // Adjusted minimal reward for high contrast exceeding optimal complementary range
  }

  // Ensure background color is complementary to both the primary and accent colors
  let background_primary_contrast = contrast(background, primary_color);
  let background_accent_contrast = contrast(background, accent_color);
  if (background_primary_contrast >= 4.5 && background_primary_contrast <= 7) {
    eval_metric += 3; // Adjusted reward for background color being complementary to primary color within optimal range
  } else if (
    background_primary_contrast > 3 &&
    background_primary_contrast < 4.5
  ) {
    eval_metric += 2; // Adjusted reward for good contrast
  } else if (
    background_primary_contrast >= 2 &&
    background_primary_contrast <= 3
  ) {
    eval_metric += 1; // Adjusted reward for acceptable contrast
  } else if (background_primary_contrast > 7) {
    eval_metric += 1; // Adjusted minimal reward for high contrast exceeding optimal complementary range
  }

  if (background_accent_contrast >= 4.5 && background_accent_contrast <= 7) {
    eval_metric += 3; // Adjusted reward for background color being complementary to accent color within optimal range
  } else if (
    background_accent_contrast > 3 &&
    background_accent_contrast < 4.5
  ) {
    eval_metric += 2; // Adjusted reward for good contrast
  } else if (
    background_accent_contrast >= 2 &&
    background_accent_contrast <= 3
  ) {
    eval_metric += 1; // Adjusted reward for acceptable contrast
  } else if (background_accent_contrast > 7) {
    eval_metric += 1; // Adjusted minimal reward for high contrast exceeding optimal complementary range
  }

  return eval_metric;
};

/**
 * Generates an initial solution for the color palette optimization.
 * It creates an array of 15 random numbers, each representing a color value.
 * The numbers are within the range of 50 to 255 to avoid extreme values.
 *
 * @returns {Array<number>} An array of 15 random numbers.
 */
export const seedInitialSolution = () =>
  Array.from({ length: 15 }, () => Math.floor(Math.random() * 206) + 50);

/**
 * Delays the execution of the next operation.
 *
 * @param {number} durationInMs - The duration to wait before resolving the promise, in milliseconds.
 * @returns {Promise<void>} A promise that resolves after the specified duration.
 */
export const sleep = (durationInMs: number): Promise<void> => {
  return new Promise((resolve) => setTimeout(resolve, durationInMs));
};
